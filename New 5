import random
import math

class QuantumInspiredOptimizer:
    """
    A simplified quantum-inspired optimization algorithm simulator.
    This class attempts to find the minimum of a given objective function
    by simulating a population of "quantum particles" that explore the search space.
    """

    def __init__(self, objective_function, search_space_bounds, num_particles=50, num_iterations=100, alpha=0.1, beta=0.01):
        """
        Initializes the QuantumInspiredOptimizer.

        Args:
            objective_function (callable): The function to be minimized.
                                          It should take a list of numerical values as input.
            search_space_bounds (list of tuples): A list where each tuple (min_val, max_val)
                                                  defines the bounds for each dimension of the search space.
            num_particles (int): The number of "quantum particles" in the simulation.
            num_iterations (int): The number of iterations for the optimization process.
            alpha (float): Parameter controlling the "quantum fluctuation" magnitude.
            beta (float): Parameter controlling the "attraction" to the best-found position.
        """
        self.objective_function = objective_function
        self.search_space_bounds = search_space_bounds
        self.num_dimensions = len(search_space_bounds)
        self.num_particles = num_particles
        self.num_iterations = num_iterations
        self.alpha = alpha
        self.beta = beta

        self.particles = []
        self.best_global_position = None
        self.best_global_fitness = float('inf')

        self._initialize_particles()

    def _initialize_particles(self):
        """Initializes the positions and "amplitudes" of the quantum-inspired particles."""
        for _ in range(self.num_particles):
            position = [random.uniform(lower, upper) for lower, upper in self.search_space_bounds]
            # Amplitudes (theta) represent a "quantum state" for each dimension
            amplitudes = [random.uniform(0, math.pi / 2) for _ in range(self.num_dimensions)]
            self.particles.append({'position': position, 'amplitudes': amplitudes, 'fitness': float('inf')})

    def _update_amplitudes(self, particle, best_personal_position, best_global_position):
        """Updates the "amplitudes" of a particle based on its best personal and global best positions."""
        for i in range(self.num_dimensions):
            r1 = random.random()
            r2 = random.random()

            # "Quantum-inspired" rotation based on best positions
            if particle['position'][i] < best_personal_position[i]:
                particle['amplitudes'][i] += self.alpha * r1
            elif particle['position'][i] > best_personal_position[i]:
                particle['amplitudes'][i] -= self.alpha * r1

            if particle['position'][i] < best_global_position[i]:
                particle['amplitudes'][i] += self.beta * r2
            elif particle['position'][i] > best_global_position[i]:
                particle['amplitudes'][i] -= self.beta * r2

            # Clamp amplitudes to [0, pi/2]
            particle['amplitudes'][i] = max(0, min(math.pi / 2, particle['amplitudes'][i]))

    def _update_position(self, particle):
        """Updates the position of a particle based on its "amplitudes" and a "quantum measurement"."""
        for i in range(self.num_dimensions):
            # Simulate "quantum measurement" to determine new position
            if random.random() < math.cos(particle['amplitudes'][i])**2:
                # Move towards lower bound
                particle['position'][i] = random.uniform(self.search_space_bounds[i][0], particle['position'][i])
            else:
                # Move towards upper bound
                particle['position'][i] = random.uniform(particle['position'][i], self.search_space_bounds[i][1])

            # Ensure position stays within bounds
            particle['position'][i] = max(self.search_space_bounds[i][0],
                                          min(self.search_space_bounds[i][1], particle['position'][i]))

    def optimize(self):
        """Runs the optimization process."""
        best_personal_positions = [p['position'] for p in self.particles]
        best_personal_fitnesses = [float('inf')] * self.num_particles

        for iteration in range(self.num_iterations):
            for i, particle in enumerate(self.particles):
                current_fitness = self.objective_function(particle['position'])
                particle['fitness'] = current_fitness

                # Update personal best
                if current_fitness < best_personal_fitnesses[i]:
                    best_personal_fitnesses[i] = current_fitness
                    best_personal_positions[i] = list(particle['position']) # Deep copy

                # Update global best
                if current_fitness < self.best_global_fitness:
                    self.best_global_fitness = current_fitness
                    self.best_global_position = list(particle['position']) # Deep copy

            # Update particles based on best positions
            for i, particle in enumerate(self.particles):
                self._update_amplitudes(particle, best_personal_positions[i], self.best_global_position)
                self._update_position(particle)

            # Optional: Print progress
            # print(f"Iteration {iteration+1}: Best Global Fitness = {self.best_global_fitness:.4f}")

        return self.best_global_position, self.best_global_fitness

# Example Usage:
if __name__ == "__main__":
    # Define an objective function (e.g., a simple quadratic function)
    def rosenbrock_function(x):
        """Rosenbrock function - a common test function for optimization algorithms."""
        if len(x) != 2:
            raise ValueError("Rosenbrock function expects a 2D input.")
        return (1 - x[0])**2 + 100 * (x[1] - x[0]**2)**2

    # Define the search space bounds for each dimension
    bounds = [(-5, 5), (-5, 5)]

    # Create and run the optimizer
    optimizer = QuantumInspiredOptimizer(rosenbrock_function, bounds,
                                         num_particles=50, num_iterations=200,
                                         alpha=0.1, beta=0.05)
    best_pos, best_fitness = optimizer.optimize()

    print(f"\nOptimization Results:")
    print(f"Best found position: {best_pos}")
    print(f"Best found fitness (minimum value): {best_fitness}")

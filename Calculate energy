import random
import math

def calculate_energy(state, problem_matrix):
    """Calculates the 'energy' of a given state based on a problem matrix."""
    energy = 0
    num_vars = len(state)
    for i in range(num_vars):
        for j in range(num_vars):
            energy += state[i] * problem_matrix[i][j] * state[j]
    return energy

def quantum_inspired_annealing(problem_matrix, num_iterations=1000, initial_temp=1.0, cooling_rate=0.99):
    """
    Performs a simplified quantum-inspired simulated annealing to find a low-energy state.
    This is a heuristic optimization, not a true quantum simulation.
    """
    num_vars = len(problem_matrix)
    current_state = [random.choice([-1, 1]) for _ in range(num_vars)]
    current_energy = calculate_energy(current_state, problem_matrix)
    best_state = list(current_state)
    best_energy = current_energy
    temperature = initial_temp

    for i in range(num_iterations):
        # Propose a new state by flipping a random bit (quantum-inspired perturbation)
        new_state = list(current_state)
        flip_index = random.randint(0, num_vars - 1)
        new_state[flip_index] *= -1  # Flip the bit

        new_energy = calculate_energy(new_state, problem_matrix)

        # Acceptance probability based on simulated annealing (with a "quantum-like" acceptance)
        if new_energy < current_energy or random.random() < math.exp(-(new_energy - current_energy) / temperature):
            current_state = list(new_state)
            current_energy = new_energy

        if current_energy < best_energy:
            best_energy = current_energy
            best_state = list(current_state)

        temperature *= cooling_rate
        if temperature < 0.001:  # Prevent temperature from becoming too small
            temperature = 0.001

    return best_state, best_energy

# --- Example Usage ---
if __name__ == "__main__":
    # Define a simple problem matrix (e.g., representing interactions in a system)
    # For a "harder" problem, this matrix would be much larger and more complex.
    problem_matrix_example = [
        [0, 1, -1],
        [1, 0, 1],
        [-1, 1, 0]
    ]

    print("Starting quantum-inspired optimization...")
    optimized_state, min_energy = quantum_inspired_annealing(problem_matrix_example)

    print(f"\nOptimized State: {optimized_state}")
    print(f"Minimum Energy Found: {min_energy}")

    # Another example with a larger matrix
    large_problem_matrix = [
        [0, 1, -1, 2, -0.5],
        [1, 0, 1, -1.5, 0.8],
        [-1, 1, 0, 0.2, -1.2],
        [2, -1.5, 0.2, 0, 0.7],
        [-0.5, 0.8, -1.2, 0.7, 0]
    ]
    print("\nStarting optimization for a larger problem...")
    optimized_state_large, min_energy_large = quantum_inspired_annealing(large_problem_matrix, num_iterations=5000)
    print(f"\nOptimized State (Large): {optimized_state_large}")
    print(f"Minimum Energy Found (Large): {min_energy_large}")
